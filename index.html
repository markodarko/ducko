<HTML>

<style>

canvas {
	display:block;
	background:black;
	user-select:none;

	}
*{
	margin: 0;
   	padding: 0;
}
</style>

<center>
<canvas id='gamewindow' width = '128' height = '64'></canvas>
</center>
<script src='controls.js'></script>
<script src='gfx/image_data.js'></script>
<script src='gfx/colors.js'></script>
<script src='gfx/sprites.js'></script>
<script>

const LEFT = 37, RIGHT = 39, UP = 38, DOWN = 40;
//const SCALE = 4, SPRITE_WIDTH = 8;
var canvas = document.getElementById('gamewindow');
var ctx = canvas.getContext('2d');

const SPRITE_WIDTH = 8,C_HEIGHT = canvas.height,C_WIDTH=canvas.width;
var SCALE = Math.trunc((window.innerHeight/canvas.height))
canvas.height = C_HEIGHT * SCALE;
canvas.width  = C_WIDTH * SCALE;
ctx.save();
ctx.scale(SCALE,SCALE);
//ctx.translate(30,0);

canvas.addEventListener('touchmove', swipeControl.move)

class dashFX{
  constructor(){
	this.reset(0,0,0,0,0)
	
  }
  update(){
	if (this.alpha>0)this.alpha-=.2;
	}

  draw(){
	if (this.alpha <= 0)return;
	ctx.globalAlpha = this.alpha;
	ctx.fillStyle = COLORS.Dgrey;
	ctx.fillRect(this.x,this.y,this.w,this.h)
	ctx.globalAlpha = 1;
  }
  reset(x,y,w,h,alpha){
	this.x = x*SPRITE_WIDTH;
	this.y=y*SPRITE_WIDTH;
	this.w=w*SPRITE_WIDTH;
	this.h=h*SPRITE_WIDTH;
	this.alpha = alpha;
  }
}

class Actor{
  constructor(x,y){
  	this.x = x;
	this.y = y;
	}
  draw(colors){
	this.sprite.drawImg(this.x*SPRITE_WIDTH,this.y*SPRITE_WIDTH,colors);
  };
  update(){
	this.sprite.updateFrame();
  }
}

class Wall extends Actor{
  constructor(x,y){
	super(x,y);
	this.sprite = SPRITES.wall;
	this.colors = [COLORS.black,COLORS.red];
  }
  draw(){
	super.draw(this.colors)
  }
}
class Hero extends Actor{
  constructor(x,y){
	super(x,y);
	this.dash = new dashFX();
	this.sprite = SPRITES.player;
	this.colors = [COLORS.Dgrey,COLORS.orange];
  }
  draw(){
	this.dash.draw()
	super.draw(this.colors)
  }
  update(){ 
	this.dash.update();
	super.update();
	//const horizontalSpeed = controller.getkeypress(RIGHT)-controller.getkeypress(LEFT)
	//const verticalSpeed = controller.getkeypress(DOWN)-controller.getkeypress(UP)
	const horizontalSpeed = (swipeControl.swipeDir == RIGHT)-(swipeControl.swipeDir == LEFT)
	const verticalSpeed = (swipeControl.swipeDir == DOWN)-(swipeControl.swipeDir == UP)
	if (horizontalSpeed) this.checkX(horizontalSpeed);
	else if(verticalSpeed) this.checkY(verticalSpeed);
	swipeControl.swipeDir = null
	
  }
  checkX(dir){
	let oldx = this.x, offset = dir < 0;
	while(this.gridCheck(this.x+dir,this.y)) this.x += dir;
	
	this.dash.reset(oldx+offset,this.y,this.x-oldx,1,2)
  }
  checkY(dir){
	let oldy = this.y, offset = dir < 0;
	while(this.gridCheck(this.x,this.y+dir)) this.y += dir;

	this.dash.reset(this.x,oldy+offset,1,this.y-oldy,2)
  }
  gridCheck(x,y){
	if (GAME.room[y][x] != 'wall') return true
  }
  screenWrap(){
	if (this.y > 8) this.y = 0;
	else if (this.y < 1) this.y = 8;
	else if (this.x > 8) this.x = 0;
	else if (this.x < 1) this.x = 8;
	else return false
	return true
  }
}

class Zombie extends Actor{
  constructor(x,y){
	super(x,y);
	this.sprite = SPRITES.zombie;
	this.colors = [COLORS.Dgreen,COLORS.Lgreen]
  }
  update(){}
}

class Goblin extends Actor{
  constructor(x,y){
	super(x,y);
	this.sprite = SPRITES.goblin;
	this.colors = [COLORS.Lgreen,COLORS.green,COLORS.Dgreen,COLORS.Dgreen]
	//this.colors = [COLORS.Lgreen,COLORS.green,COLORS.black,COLORS.orange]
	//this.colors = [COLORS.Lgreen,COLORS.Lgreen,COLORS.black,COLORS.Lgreen]
  }
  update(){}
}

class GameControl{

  constructor(){
	this.resetLevel();
	this.buildRoom(ROOMS[0]);
  }

  resetLevel(){
	this.room = [[],[],[],[],[],[],[],[]];
	this.actors = {
	  enemies:[],
	  walls:  [],
	  stairs: [],
	  wallsFG:[]
	}
  }

  draw(){
	const A = this.actors;
	const OBJS = [...A.walls,...A.enemies,A.player];
	OBJS.forEach(obj => {
	  obj.draw();
	})
  }

  update(){
	this.actors.player.update()
  }
  buildRoom(map){
	const WIDTH = 8;
	for(let row = 0; row < WIDTH; row++){
	  for (let col = 0; col < WIDTH; col++){
		switch(map[row*WIDTH + col]){
		  case '1': 
			this.room[row].push('wall')
			this.actors.walls.push(new Wall(col,row))
		  break;
		  case 'p':
			this.actors.player = new Hero(col,row)
		  default: this.room[row].push('empty')

		}
	  }	
	}
  }
}

const ROOMS = {
  0:
	'11111111'+
	'1......1'+
	'1......1'+
	'1...p.11'+
	'11.....1'+
	'1.z....1'+
	'1....z.1'+
	'11111111'
	,
  1:	'11111111'+
	'1......1'+
	'1....1.1'+
	'1..11111'+
	'11.....1'+
	'1p1....1'+
	'1......1'+
	'11111111'
}

function mainloop(){
var newSCALE = Math.ceil((window.innerHeight/C_HEIGHT))
if (newSCALE != SCALE){
	SCALE = newSCALE;
	canvas.height = C_HEIGHT * SCALE;
	canvas.width  = C_WIDTH * SCALE;
	ctx.restore()
	ctx.scale(SCALE,SCALE)
}
ctx.clearRect(0,0,canvas.width,canvas.height)
GAME.update();
GAME.draw();
requestAnimationFrame(mainloop)
}
var GAME = new GameControl()
gob = new Goblin(10,4)
zom = new Zombie(8,1)
mainloop()





</script>